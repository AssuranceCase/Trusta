{
    "main": "int main(int argc, char **argv)\n{\n    qemu_init(argc, argv);\n    return qemu_default_main();\n}",
    "qemu_default_main": "int qemu_default_main(void)\n{\n    int status;\n\n    status = qemu_main_loop();\n    qemu_cleanup();\n\n    return status;\n}",
    "memory_region_transaction_commit": "void memory_region_transaction_commit(void)\n{\n    AddressSpace *as;\n\n    assert(memory_region_transaction_depth);\n    assert(qemu_mutex_iothread_locked());\n\n    --memory_region_transaction_depth;\n    if (!memory_region_transaction_depth) {\n        if (memory_region_update_pending) {\n            flatviews_reset();\n\n            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);\n\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_set_flatview(as);\n                address_space_update_ioeventfds(as);\n            }\n            memory_region_update_pending = false;\n            ioeventfd_update_pending = false;\n            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);\n        } else if (ioeventfd_update_pending) {\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_ioeventfds(as);\n            }\n            ioeventfd_update_pending = false;\n        }\n    }\n}",
    "generate_memory_topology": "/* Render a memory topology into a list of disjoint absolute ranges. */\nstatic FlatView *generate_memory_topology(MemoryRegion *mr)\n{\n    int i;\n    FlatView *view;\n\n    view = flatview_new(mr);\n\n    if (mr) {\n        render_memory_region(view, mr, int128_zero(),\n                                addrrange_make(int128_zero(), int128_2_64()),\n                                false, false);\n    }\n    flatview_simplify(view);\n\n    view->dispatch = address_space_dispatch_new(view);\n    for (i = 0; i < view->nr; i++) {\n        MemoryRegionSection mrs =\n            section_from_flat_range(&view->ranges[i], view);\n        flatview_add_to_dispatch(view, &mrs);\n    }\n    address_space_dispatch_compact(view->dispatch);\n    g_hash_table_replace(flat_views, mr, view);\n\n    return view;\n}",
    "address_space_set_flatview": "static void address_space_set_flatview(AddressSpace *as)\n{\n    FlatView *old_view = address_space_to_flatview(as);\n    MemoryRegion *physmr = memory_region_get_flatview_root(as->root);\n    FlatView *new_view = g_hash_table_lookup(flat_views, physmr);\n\n    assert(new_view);\n\n    if (old_view == new_view) {\n        return;\n    }\n\n    if (old_view) {\n        flatview_ref(old_view);\n    }\n\n    flatview_ref(new_view);\n\n    if (!QTAILQ_EMPTY(&as->listeners)) {\n        FlatView tmpview = { .nr = 0 }, *old_view2 = old_view;\n\n        if (!old_view2) {\n            old_view2 = &tmpview;\n        }\n        address_space_update_topology_pass(as, old_view2, new_view, false);\n        address_space_update_topology_pass(as, old_view2, new_view, true);\n    }\n\n    /* Writes are protected by the BQL.  */\n    qatomic_rcu_set(&as->current_map, new_view);\n    if (old_view) {\n        flatview_unref(old_view);\n    }\n\n    /* Note that all the old MemoryRegions are still alive up to this\n        * point.  This relieves most MemoryListeners from the need to\n        * ref/unref the MemoryRegions they get---unless they use them\n        * outside the iothread mutex, in which case precise reference\n        * counting is necessary.\n        */\n    if (old_view) {\n        flatview_unref(old_view);\n    }\n}",
    "flatview_add_to_dispatch": "/*\n* The range in *section* may look like this:\n*\n*      |s|PPPPPPP|s|\n*\n* where s stands for subpage and P for page.\n*/\nvoid flatview_add_to_dispatch(FlatView *fv, MemoryRegionSection *section)\n{\n    MemoryRegionSection remain = *section;\n    Int128 page_size = int128_make64(TARGET_PAGE_SIZE);\n\n    /* register first subpage */\n    if (remain.offset_within_address_space & ~TARGET_PAGE_MASK) {\n        uint64_t left = TARGET_PAGE_ALIGN(remain.offset_within_address_space)\n                        - remain.offset_within_address_space;\n\n        MemoryRegionSection now = remain;\n        now.size = int128_min(int128_make64(left), now.size);\n        register_subpage(fv, &now);\n        if (int128_eq(remain.size, now.size)) {\n            return;\n        }\n        remain.size = int128_sub(remain.size, now.size);\n        remain.offset_within_address_space += int128_get64(now.size);\n        remain.offset_within_region += int128_get64(now.size);\n    }\n\n    /* register whole pages */\n    if (int128_ge(remain.size, page_size)) {\n        MemoryRegionSection now = remain;\n        now.size = int128_and(now.size, int128_neg(page_size));\n        register_multipage(fv, &now);\n        if (int128_eq(remain.size, now.size)) {\n            return;\n        }\n        remain.size = int128_sub(remain.size, now.size);\n        remain.offset_within_address_space += int128_get64(now.size);\n        remain.offset_within_region += int128_get64(now.size);\n    }\n\n    /* register last subpage */\n    register_subpage(fv, &remain);\n}\n",
    "address_space_dispatch_compact": "void address_space_dispatch_compact(AddressSpaceDispatch *d)\n{\n    if (d->phys_map.skip) {\n        phys_page_compact(&d->phys_map, d->map.nodes);\n    }\n}",
    "address_space_update_topology_pass": "static void address_space_update_topology_pass(AddressSpace *as,\n                                                const FlatView *old_view,\n                                                const FlatView *new_view,\n                                                bool adding)\n{\n    unsigned iold, inew;\n    FlatRange *frold, *frnew;\n\n    /* Generate a symmetric difference of the old and new memory maps.\n        * Kill ranges in the old map, and instantiate ranges in the new map.\n        */\n    iold = inew = 0;\n    while (iold < old_view->nr || inew < new_view->nr) {\n        if (iold < old_view->nr) {\n            frold = &old_view->ranges[iold];\n        } else {\n            frold = NULL;\n        }\n        if (inew < new_view->nr) {\n            frnew = &new_view->ranges[inew];\n        } else {\n            frnew = NULL;\n        }\n\n        if (frold\n            && (!frnew\n                || int128_lt(frold->addr.start, frnew->addr.start)\n                || (int128_eq(frold->addr.start, frnew->addr.start)\n                    && !flatrange_equal(frold, frnew)))) {\n            /* In old but not in new, or in both but attributes changed. */\n\n            if (!adding) {\n                flat_range_coalesced_io_del(frold, as);\n                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);\n            }\n\n            ++iold;\n        } else if (frold && frnew && flatrange_equal(frold, frnew)) {\n            /* In both and unchanged (except logging may have changed) */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);\n                if (frnew->dirty_log_mask & ~frold->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start,\n                                                    frold->dirty_log_mask,\n                                                    frnew->dirty_log_mask);\n                }\n                if (frold->dirty_log_mask & ~frnew->dirty_log_mask) {\n                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop,\n                                                    frold->dirty_log_mask,\n                                                    frnew->dirty_log_mask);\n                }\n            }\n\n            ++iold;\n            ++inew;\n        } else {\n            /* In new */\n\n            if (adding) {\n                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);\n                flat_range_coalesced_io_add(frnew, as);\n            }\n\n            ++inew;\n        }\n    }\n}",
    "phys_page_set": "static void phys_page_set(AddressSpaceDispatch *d,\n    hwaddr index, uint64_t nb,\n    uint16_t leaf)\n{\n/* Wildly overreserve - it doesn't matter much. */\nphys_map_node_reserve(&d->map, 3 * P_L2_LEVELS);\n\nphys_page_set_level(&d->map, &d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n}",
    "register_subpage": "static void register_subpage(FlatView *fv, MemoryRegionSection *section)\n{\n    AddressSpaceDispatch *d = flatview_to_dispatch(fv);\n    subpage_t *subpage;\n    hwaddr base = section->offset_within_address_space\n        & TARGET_PAGE_MASK;\n    MemoryRegionSection *existing = phys_page_find(d, base);\n    MemoryRegionSection subsection = {\n        .offset_within_address_space = base,\n        .size = int128_make64(TARGET_PAGE_SIZE),\n    };\n    hwaddr start, end;\n\n    assert(existing->mr->subpage || existing->mr == &io_mem_unassigned);\n\n    if (!(existing->mr->subpage)) {\n        subpage = subpage_init(fv, base);\n        subsection.fv = fv;\n        subsection.mr = &subpage->iomem;\n        phys_page_set(d, base >> TARGET_PAGE_BITS, 1,\n                        phys_section_add(&d->map, &subsection));\n    } else {\n        subpage = container_of(existing->mr, subpage_t, iomem);\n    }\n    start = section->offset_within_address_space & ~TARGET_PAGE_MASK;\n    end = start + int128_get64(section->size) - 1;\n    subpage_register(subpage, start, end,\n                        phys_section_add(&d->map, section));\n}",
    "qmp_x_exit_preconfig.part.0": "void qmp_x_exit_preconfig(Error **errp)\n{\n    if (phase_check(PHASE_MACHINE_INITIALIZED)) {\n        error_setg(errp, \"The command is permitted only before machine initialization\");\n        return;\n    }\n\n    qemu_init_board();\n    qemu_create_cli_devices();\n    qemu_machine_creation_done();\n\n    if (loadvm) {\n        load_snapshot(loadvm, NULL, false, NULL, &error_fatal);\n    }\n    if (replay_mode != REPLAY_MODE_NONE) {\n        replay_vmstate_init();\n    }\n\n    if (incoming) {\n        Error *local_err = NULL;\n        if (strcmp(incoming, \"defer\") != 0) {\n            qmp_migrate_incoming(incoming, &local_err);\n            if (local_err) {\n                error_reportf_err(local_err, \"-incoming %s: \", incoming);\n                exit(1);\n            }\n        }\n    } else if (autostart) {\n        qmp_cont(NULL);\n    }\n}",
    "object_class_get_list": "GSList *object_class_get_list(const char *implements_type, bool include_abstract)\n{\nGSList *list = NULL;\n\nobject_class_foreach(object_class_get_list_tramp,\nimplements_type, include_abstract, &list);\nreturn list;\n}",
    "qemu_init": "void qemu_init(int argc, char **argv)\n{\n    QemuOpts *opts;\n    QemuOpts *icount_opts = NULL, *accel_opts = NULL;\n    QemuOptsList *olist;\n    int optind;\n    const char *optarg;\n    MachineClass *machine_class;\n    bool userconfig = true;\n    FILE *vmstate_dump_file = NULL;\n\n    qemu_add_opts(&qemu_drive_opts);\n    qemu_add_drive_opts(&qemu_legacy_drive_opts);\n    qemu_add_drive_opts(&qemu_common_drive_opts);\n    qemu_add_drive_opts(&qemu_drive_opts);\n    qemu_add_drive_opts(&bdrv_runtime_opts);\n    qemu_add_opts(&qemu_chardev_opts);\n    qemu_add_opts(&qemu_device_opts);\n    qemu_add_opts(&qemu_netdev_opts);\n    qemu_add_opts(&qemu_nic_opts);\n    qemu_add_opts(&qemu_net_opts);\n    qemu_add_opts(&qemu_rtc_opts);\n    qemu_add_opts(&qemu_global_opts);\n    qemu_add_opts(&qemu_mon_opts);\n    qemu_add_opts(&qemu_trace_opts);\n    qemu_plugin_add_opts();\n    qemu_add_opts(&qemu_option_rom_opts);\n    qemu_add_opts(&qemu_accel_opts);\n    qemu_add_opts(&qemu_mem_opts);\n    qemu_add_opts(&qemu_smp_opts);\n    qemu_add_opts(&qemu_boot_opts);\n    qemu_add_opts(&qemu_add_fd_opts);\n    qemu_add_opts(&qemu_object_opts);\n    qemu_add_opts(&qemu_tpmdev_opts);\n    qemu_add_opts(&qemu_overcommit_opts);\n    qemu_add_opts(&qemu_msg_opts);\n    qemu_add_opts(&qemu_name_opts);\n    qemu_add_opts(&qemu_numa_opts);\n    qemu_add_opts(&qemu_icount_opts);\n    qemu_add_opts(&qemu_semihosting_config_opts);\n    qemu_add_opts(&qemu_fw_cfg_opts);\n    qemu_add_opts(&qemu_action_opts);\n    module_call_init(MODULE_INIT_OPTS);\n\n    error_init(argv[0]);\n    qemu_init_exec_dir(argv[0]);\n\n    qemu_init_arch_modules();\n\n    qemu_init_subsystems();\n\n    /* first pass of option parsing */\n    optind = 1;\n    while (optind < argc) {\n        if (argv[optind][0] != '-') {\n            /* disk image */\n            optind++;\n        } else {\n            const QEMUOption *popt;\n\n            popt = lookup_opt(argc, argv, &optarg, &optind);\n            switch (popt->index) {\n            case QEMU_OPTION_nouserconfig:\n                userconfig = false;\n                break;\n            }\n        }\n    }\n\n    machine_opts_dict = qdict_new();\n    if (userconfig) {\n        qemu_read_default_config_file(&error_fatal);\n    }\n\n    /* second pass of option parsing */\n    optind = 1;\n    for(;;) {\n        if (optind >= argc)\n            break;\n        if (argv[optind][0] != '-') {\n            loc_set_cmdline(argv, optind, 1);\n            drive_add(IF_DEFAULT, 0, argv[optind++], HD_OPTS);\n        } else {\n            const QEMUOption *popt;\n\n            popt = lookup_opt(argc, argv, &optarg, &optind);\n            if (!(popt->arch_mask & arch_type)) {\n                error_report(\"Option not supported for this target\");\n                exit(1);\n            }\n            switch(popt->index) {\n            case QEMU_OPTION_cpu:\n                /* hw initialization will check this */\n                cpu_option = optarg;\n                break;\n            case QEMU_OPTION_hda:\n            case QEMU_OPTION_hdb:\n            case QEMU_OPTION_hdc:\n            case QEMU_OPTION_hdd:\n                drive_add(IF_DEFAULT, popt->index - QEMU_OPTION_hda, optarg,\n                          HD_OPTS);\n                break;\n            case QEMU_OPTION_blockdev:\n                {\n                    Visitor *v;\n                    BlockdevOptionsQueueEntry *bdo;\n\n                    v = qobject_input_visitor_new_str(optarg, \"driver\",\n                                                      &error_fatal);\n\n                    bdo = g_new(BlockdevOptionsQueueEntry, 1);\n                    visit_type_BlockdevOptions(v, NULL, &bdo->bdo,\n                                               &error_fatal);\n                    visit_free(v);\n                    loc_save(&bdo->loc);\n                    QSIMPLEQ_INSERT_TAIL(&bdo_queue, bdo, entry);\n                    break;\n                }\n            case QEMU_OPTION_drive:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"drive\"),\n                                               optarg, false);\n                if (opts == NULL) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_set:\n                qemu_set_option(optarg, &error_fatal);\n                break;\n            case QEMU_OPTION_global:\n                if (qemu_global_option(optarg) != 0)\n                    exit(1);\n                break;\n            case QEMU_OPTION_mtdblock:\n                drive_add(IF_MTD, -1, optarg, MTD_OPTS);\n                break;\n            case QEMU_OPTION_sd:\n                drive_add(IF_SD, -1, optarg, SD_OPTS);\n                break;\n            case QEMU_OPTION_pflash:\n                drive_add(IF_PFLASH, -1, optarg, PFLASH_OPTS);\n                break;\n            case QEMU_OPTION_snapshot:\n                snapshot = 1;\n                replay_add_blocker(\"-snapshot\");\n                break;\n            case QEMU_OPTION_numa:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"numa\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_display:\n                parse_display(optarg);\n                break;\n            case QEMU_OPTION_nographic:\n                qdict_put_str(machine_opts_dict, \"graphics\", \"off\");\n                nographic = true;\n                dpy.type = DISPLAY_TYPE_NONE;\n                break;\n            case QEMU_OPTION_portrait:\n                graphic_rotate = 90;\n                break;\n            case QEMU_OPTION_rotate:\n                graphic_rotate = strtol(optarg, (char **) &optarg, 10);\n                if (graphic_rotate != 0 && graphic_rotate != 90 &&\n                    graphic_rotate != 180 && graphic_rotate != 270) {\n                    error_report(\"only 90, 180, 270 deg rotation is available\");\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_kernel:\n                qdict_put_str(machine_opts_dict, \"kernel\", optarg);\n                break;\n            case QEMU_OPTION_initrd:\n                qdict_put_str(machine_opts_dict, \"initrd\", optarg);\n                break;\n            case QEMU_OPTION_append:\n                qdict_put_str(machine_opts_dict, \"append\", optarg);\n                break;\n            case QEMU_OPTION_dtb:\n                qdict_put_str(machine_opts_dict, \"dtb\", optarg);\n                break;\n            case QEMU_OPTION_cdrom:\n                drive_add(IF_DEFAULT, 2, optarg, CDROM_OPTS);\n                break;\n            case QEMU_OPTION_boot:\n                machine_parse_property_opt(qemu_find_opts(\"boot-opts\"), \"boot\", optarg);\n                break;\n            case QEMU_OPTION_fda:\n            case QEMU_OPTION_fdb:\n                drive_add(IF_FLOPPY, popt->index - QEMU_OPTION_fda,\n                          optarg, FD_OPTS);\n                break;\n            case QEMU_OPTION_no_fd_bootchk:\n                fd_bootchk = 0;\n                break;\n            case QEMU_OPTION_netdev:\n                default_net = 0;\n                if (netdev_is_modern(optarg)) {\n                    netdev_parse_modern(optarg);\n                } else {\n                    net_client_parse(qemu_find_opts(\"netdev\"), optarg);\n                }\n                break;\n            case QEMU_OPTION_nic:\n                default_net = 0;\n                net_client_parse(qemu_find_opts(\"nic\"), optarg);\n                break;\n            case QEMU_OPTION_net:\n                default_net = 0;\n                net_client_parse(qemu_find_opts(\"net\"), optarg);\n                break;\n#ifdef CONFIG_LIBISCSI\n            case QEMU_OPTION_iscsi:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"iscsi\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n#endif\n            case QEMU_OPTION_audio_help:\n                audio_legacy_help();\n                exit (0);\n                break;\n            case QEMU_OPTION_audiodev:\n                audio_parse_option(optarg);\n                break;\n            case QEMU_OPTION_audio: {\n                bool help;\n                char *model;\n                Audiodev *dev = NULL;\n                Visitor *v;\n                QDict *dict = keyval_parse(optarg, \"driver\", &help, &error_fatal);\n                if (help || (qdict_haskey(dict, \"driver\") &&\n                             is_help_option(qdict_get_str(dict, \"driver\")))) {\n                    audio_help();\n                    exit(EXIT_SUCCESS);\n                }\n                if (!qdict_haskey(dict, \"id\")) {\n                    qdict_put_str(dict, \"id\", \"audiodev0\");\n                }\n                if (!qdict_haskey(dict, \"model\")) {\n                    error_setg(&error_fatal, \"Parameter 'model' is missing\");\n                }\n                model = g_strdup(qdict_get_str(dict, \"model\"));\n                qdict_del(dict, \"model\");\n                if (is_help_option(model)) {\n                    show_valid_soundhw();\n                    exit(0);\n                }\n                v = qobject_input_visitor_new_keyval(QOBJECT(dict));\n                qobject_unref(dict);\n                visit_type_Audiodev(v, NULL, &dev, &error_fatal);\n                visit_free(v);\n                audio_define(dev);\n                select_soundhw(model, dev->id);\n                g_free(model);\n                break;\n            }\n            case QEMU_OPTION_h:\n                help(0);\n                break;\n            case QEMU_OPTION_version:\n                version();\n                exit(0);\n                break;\n            case QEMU_OPTION_m:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"memory\"), optarg, true);\n                if (opts == NULL) {\n                    exit(1);\n                }\n                break;\n#ifdef CONFIG_TPM\n            case QEMU_OPTION_tpmdev:\n                if (tpm_config_parse(qemu_find_opts(\"tpmdev\"), optarg) < 0) {\n                    exit(1);\n                }\n                break;\n#endif\n            case QEMU_OPTION_mempath:\n                mem_path = optarg;\n                break;\n            case QEMU_OPTION_mem_prealloc:\n                mem_prealloc = 1;\n                break;\n            case QEMU_OPTION_d:\n                log_mask = optarg;\n                break;\n            case QEMU_OPTION_D:\n                log_file = optarg;\n                break;\n            case QEMU_OPTION_DFILTER:\n                qemu_set_dfilter_ranges(optarg, &error_fatal);\n                break;\n#if defined(CONFIG_TCG) && defined(CONFIG_LINUX)\n            case QEMU_OPTION_perfmap:\n                perf_enable_perfmap();\n                break;\n            case QEMU_OPTION_jitdump:\n                perf_enable_jitdump();\n                break;\n#endif\n            case QEMU_OPTION_seed:\n                qemu_guest_random_seed_main(optarg, &error_fatal);\n                break;\n            case QEMU_OPTION_s:\n                add_device_config(DEV_GDB, \"tcp::\" DEFAULT_GDBSTUB_PORT);\n                break;\n            case QEMU_OPTION_gdb:\n                add_device_config(DEV_GDB, optarg);\n                break;\n            case QEMU_OPTION_L:\n                if (is_help_option(optarg)) {\n                    list_data_dirs = true;\n                } else {\n                    qemu_add_data_dir(g_strdup(optarg));\n                }\n                break;\n            case QEMU_OPTION_bios:\n                qdict_put_str(machine_opts_dict, \"firmware\", optarg);\n                break;\n            case QEMU_OPTION_singlestep:\n                singlestep = 1;\n                break;\n            case QEMU_OPTION_S:\n                autostart = 0;\n                break;\n            case QEMU_OPTION_k:\n                keyboard_layout = optarg;\n                break;\n            case QEMU_OPTION_vga:\n                vga_model = optarg;\n                default_vga = 0;\n                break;\n            case QEMU_OPTION_g:\n                {\n                    const char *p;\n                    int w, h, depth;\n                    p = optarg;\n                    w = strtol(p, (char **)&p, 10);\n                    if (w <= 0) {\n                    graphic_error:\n                        error_report(\"invalid resolution or depth\");\n                        exit(1);\n                    }\n                    if (*p != 'x')\n                        goto graphic_error;\n                    p++;\n                    h = strtol(p, (char **)&p, 10);\n                    if (h <= 0)\n                        goto graphic_error;\n                    if (*p == 'x') {\n                        p++;\n                        depth = strtol(p, (char **)&p, 10);\n                        if (depth != 1 && depth != 2 && depth != 4 &&\n                            depth != 8 && depth != 15 && depth != 16 &&\n                            depth != 24 && depth != 32)\n                            goto graphic_error;\n                    } else if (*p == '\\0') {\n                        depth = graphic_depth;\n                    } else {\n                        goto graphic_error;\n                    }\n\n                    graphic_width = w;\n                    graphic_height = h;\n                    graphic_depth = depth;\n                }\n                break;\n            case QEMU_OPTION_echr:\n                {\n                    char *r;\n                    term_escape_char = strtol(optarg, &r, 0);\n                    if (r == optarg)\n                        printf(\"Bad argument to echr\\n\");\n                    break;\n                }\n            case QEMU_OPTION_monitor:\n                default_monitor = 0;\n                if (strncmp(optarg, \"none\", 4)) {\n                    monitor_parse(optarg, \"readline\", false);\n                }\n                break;\n            case QEMU_OPTION_qmp:\n                monitor_parse(optarg, \"control\", false);\n                default_monitor = 0;\n                break;\n            case QEMU_OPTION_qmp_pretty:\n                monitor_parse(optarg, \"control\", true);\n                default_monitor = 0;\n                break;\n            case QEMU_OPTION_mon:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"mon\"), optarg,\n                                               true);\n                if (!opts) {\n                    exit(1);\n                }\n                default_monitor = 0;\n                break;\n            case QEMU_OPTION_chardev:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"chardev\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_fsdev:\n                olist = qemu_find_opts(\"fsdev\");\n                if (!olist) {\n                    error_report(\"fsdev support is disabled\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_virtfs: {\n                QemuOpts *fsdev;\n                QemuOpts *device;\n                const char *writeout, *sock_fd, *socket, *path, *security_model,\n                           *multidevs;\n\n                olist = qemu_find_opts(\"virtfs\");\n                if (!olist) {\n                    error_report(\"virtfs support is disabled\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n\n                if (qemu_opt_get(opts, \"fsdriver\") == NULL ||\n                    qemu_opt_get(opts, \"mount_tag\") == NULL) {\n                    error_report(\"Usage: -virtfs fsdriver,mount_tag=tag\");\n                    exit(1);\n                }\n                fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n                                         qemu_opts_id(opts) ?:\n                                         qemu_opt_get(opts, \"mount_tag\"),\n                                         1, NULL);\n                if (!fsdev) {\n                    error_report(\"duplicate or invalid fsdev id: %s\",\n                                 qemu_opt_get(opts, \"mount_tag\"));\n                    exit(1);\n                }\n\n                writeout = qemu_opt_get(opts, \"writeout\");\n                if (writeout) {\n#ifdef CONFIG_SYNC_FILE_RANGE\n                    qemu_opt_set(fsdev, \"writeout\", writeout, &error_abort);\n#else\n                    error_report(\"writeout=immediate not supported \"\n                                 \"on this platform\");\n                    exit(1);\n#endif\n                }\n                qemu_opt_set(fsdev, \"fsdriver\",\n                             qemu_opt_get(opts, \"fsdriver\"), &error_abort);\n                path = qemu_opt_get(opts, \"path\");\n                if (path) {\n                    qemu_opt_set(fsdev, \"path\", path, &error_abort);\n                }\n                security_model = qemu_opt_get(opts, \"security_model\");\n                if (security_model) {\n                    qemu_opt_set(fsdev, \"security_model\", security_model,\n                                 &error_abort);\n                }\n                socket = qemu_opt_get(opts, \"socket\");\n                if (socket) {\n                    qemu_opt_set(fsdev, \"socket\", socket, &error_abort);\n                }\n                sock_fd = qemu_opt_get(opts, \"sock_fd\");\n                if (sock_fd) {\n                    qemu_opt_set(fsdev, \"sock_fd\", sock_fd, &error_abort);\n                }\n\n                qemu_opt_set_bool(fsdev, \"readonly\",\n                                  qemu_opt_get_bool(opts, \"readonly\", 0),\n                                  &error_abort);\n                multidevs = qemu_opt_get(opts, \"multidevs\");\n                if (multidevs) {\n                    qemu_opt_set(fsdev, \"multidevs\", multidevs, &error_abort);\n                }\n                device = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                          &error_abort);\n                qemu_opt_set(device, \"driver\", \"virtio-9p-pci\", &error_abort);\n                qemu_opt_set(device, \"fsdev\",\n                             qemu_opts_id(fsdev), &error_abort);\n                qemu_opt_set(device, \"mount_tag\",\n                             qemu_opt_get(opts, \"mount_tag\"), &error_abort);\n                break;\n            }\n            case QEMU_OPTION_serial:\n                add_device_config(DEV_SERIAL, optarg);\n                default_serial = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n                }\n                break;\n            case QEMU_OPTION_action:\n                olist = qemu_find_opts(\"action\");\n                if (!qemu_opts_parse_noisily(olist, optarg, false)) {\n                     exit(1);\n                }\n                break;\n            case QEMU_OPTION_watchdog_action: {\n                QemuOpts *opts;\n                opts = qemu_opts_create(qemu_find_opts(\"action\"), NULL, 0, &error_abort);\n                qemu_opt_set(opts, \"watchdog\", optarg, &error_abort);\n                break;\n            }\n            case QEMU_OPTION_parallel:\n                add_device_config(DEV_PARALLEL, optarg);\n                default_parallel = 0;\n                if (strncmp(optarg, \"mon:\", 4) == 0) {\n                    default_monitor = 0;\n                }\n                break;\n            case QEMU_OPTION_debugcon:\n                add_device_config(DEV_DEBUGCON, optarg);\n                break;\n            case QEMU_OPTION_loadvm:\n                loadvm = optarg;\n                break;\n            case QEMU_OPTION_full_screen:\n                dpy.has_full_screen = true;\n                dpy.full_screen = true;\n                break;\n            case QEMU_OPTION_pidfile:\n                pid_file = optarg;\n                break;\n            case QEMU_OPTION_win2k_hack:\n                win2k_install_hack = 1;\n                break;\n            case QEMU_OPTION_acpitable:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"acpi\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                acpi_table_add(opts, &error_fatal);\n                break;\n            case QEMU_OPTION_smbios:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"smbios\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                smbios_entry_add(opts, &error_fatal);\n                break;\n            case QEMU_OPTION_fwcfg:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"fw_cfg\"),\n                                               optarg, true);\n                if (opts == NULL) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_preconfig:\n                preconfig_requested = true;\n                break;\n            case QEMU_OPTION_enable_kvm:\n                qdict_put_str(machine_opts_dict, \"accel\", \"kvm\");\n                break;\n            case QEMU_OPTION_M:\n            case QEMU_OPTION_machine:\n                {\n                    bool help;\n\n                    keyval_parse_into(machine_opts_dict, optarg, \"type\", &help, &error_fatal);\n                    if (help) {\n                        machine_help_func(machine_opts_dict);\n                        exit(EXIT_SUCCESS);\n                    }\n                    break;\n                }\n            case QEMU_OPTION_accel:\n                accel_opts = qemu_opts_parse_noisily(qemu_find_opts(\"accel\"),\n                                                     optarg, true);\n                optarg = qemu_opt_get(accel_opts, \"accel\");\n                if (!optarg || is_help_option(optarg)) {\n                    printf(\"Accelerators supported in QEMU binary:\\n\");\n                    GSList *el, *accel_list = object_class_get_list(TYPE_ACCEL,\n                                                                    false);\n                    for (el = accel_list; el; el = el->next) {\n                        gchar *typename = g_strdup(object_class_get_name(\n                                                   OBJECT_CLASS(el->data)));\n                        /* omit qtest which is used for tests only */\n                        if (g_strcmp0(typename, ACCEL_CLASS_NAME(\"qtest\")) &&\n                            g_str_has_suffix(typename, ACCEL_CLASS_SUFFIX)) {\n                            gchar **optname = g_strsplit(typename,\n                                                         ACCEL_CLASS_SUFFIX, 0);\n                            printf(\"%s\\n\", optname[0]);\n                            g_strfreev(optname);\n                        }\n                        g_free(typename);\n                    }\n                    g_slist_free(accel_list);\n                    exit(0);\n                }\n                break;\n            case QEMU_OPTION_usb:\n                qdict_put_str(machine_opts_dict, \"usb\", \"on\");\n                break;\n            case QEMU_OPTION_usbdevice:\n                qdict_put_str(machine_opts_dict, \"usb\", \"on\");\n                add_device_config(DEV_USB, optarg);\n                break;\n            case QEMU_OPTION_device:\n                if (optarg[0] == '{') {\n                    QObject *obj = qobject_from_json(optarg, &error_fatal);\n                    DeviceOption *opt = g_new0(DeviceOption, 1);\n                    opt->opts = qobject_to(QDict, obj);\n                    loc_save(&opt->loc);\n                    assert(opt->opts != NULL);\n                    QTAILQ_INSERT_TAIL(&device_opts, opt, next);\n                } else {\n                    if (!qemu_opts_parse_noisily(qemu_find_opts(\"device\"),\n                                                 optarg, true)) {\n                        exit(1);\n                    }\n                }\n                break;\n            case QEMU_OPTION_smp:\n                machine_parse_property_opt(qemu_find_opts(\"smp-opts\"),\n                                           \"smp\", optarg);\n                break;\n            case QEMU_OPTION_vnc:\n                vnc_parse(optarg);\n                break;\n            case QEMU_OPTION_no_acpi:\n                warn_report(\"-no-acpi is deprecated, use '-machine acpi=off' instead\");\n                qdict_put_str(machine_opts_dict, \"acpi\", \"off\");\n                break;\n            case QEMU_OPTION_no_hpet:\n                warn_report(\"-no-hpet is deprecated, use '-machine hpet=off' instead\");\n                qdict_put_str(machine_opts_dict, \"hpet\", \"off\");\n                break;\n            case QEMU_OPTION_no_reboot:\n                olist = qemu_find_opts(\"action\");\n                qemu_opts_parse_noisily(olist, \"reboot=shutdown\", false);\n                break;\n            case QEMU_OPTION_no_shutdown:\n                olist = qemu_find_opts(\"action\");\n                qemu_opts_parse_noisily(olist, \"shutdown=pause\", false);\n                break;\n            case QEMU_OPTION_uuid:\n                if (qemu_uuid_parse(optarg, &qemu_uuid) < 0) {\n                    error_report(\"failed to parse UUID string: wrong format\");\n                    exit(1);\n                }\n                qemu_uuid_set = true;\n                break;\n            case QEMU_OPTION_option_rom:\n                if (nb_option_roms >= MAX_OPTION_ROMS) {\n                    error_report(\"too many option ROMs\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"option-rom\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                option_rom[nb_option_roms].name = qemu_opt_get(opts, \"romfile\");\n                option_rom[nb_option_roms].bootindex =\n                    qemu_opt_get_number(opts, \"bootindex\", -1);\n                if (!option_rom[nb_option_roms].name) {\n                    error_report(\"Option ROM file is not specified\");\n                    exit(1);\n                }\n                nb_option_roms++;\n                break;\n            case QEMU_OPTION_semihosting:\n                qemu_semihosting_enable();\n                break;\n            case QEMU_OPTION_semihosting_config:\n                if (qemu_semihosting_config_options(optarg) != 0) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_name:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"name\"),\n                                               optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                /* Capture guest name if -msg guest-name is used later */\n                error_guest_name = qemu_opt_get(opts, \"guest\");\n                break;\n            case QEMU_OPTION_prom_env:\n                if (nb_prom_envs >= MAX_PROM_ENVS) {\n                    error_report(\"too many prom variables\");\n                    exit(1);\n                }\n                prom_envs[nb_prom_envs] = optarg;\n                nb_prom_envs++;\n                break;\n            case QEMU_OPTION_old_param:\n                old_param = 1;\n                break;\n            case QEMU_OPTION_rtc:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"rtc\"), optarg,\n                                               false);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_icount:\n                icount_opts = qemu_opts_parse_noisily(qemu_find_opts(\"icount\"),\n                                                      optarg, true);\n                if (!icount_opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_incoming:\n                if (!incoming) {\n                    runstate_set(RUN_STATE_INMIGRATE);\n                }\n                incoming = optarg;\n                break;\n            case QEMU_OPTION_only_migratable:\n                only_migratable = 1;\n                break;\n            case QEMU_OPTION_nodefaults:\n                has_defaults = 0;\n                break;\n            case QEMU_OPTION_xen_domid:\n                if (!(accel_find(\"xen\")) && !(accel_find(\"kvm\"))) {\n                    error_report(\"Option not supported for this target\");\n                    exit(1);\n                }\n                xen_domid = atoi(optarg);\n                break;\n            case QEMU_OPTION_xen_attach:\n                if (!(accel_find(\"xen\"))) {\n                    error_report(\"Option not supported for this target\");\n                    exit(1);\n                }\n                xen_mode = XEN_ATTACH;\n                break;\n            case QEMU_OPTION_xen_domid_restrict:\n                if (!(accel_find(\"xen\"))) {\n                    error_report(\"Option not supported for this target\");\n                    exit(1);\n                }\n                xen_domid_restrict = true;\n                break;\n            case QEMU_OPTION_trace:\n                trace_opt_parse(optarg);\n                break;\n            case QEMU_OPTION_plugin:\n                qemu_plugin_opt_parse(optarg, &plugin_list);\n                break;\n            case QEMU_OPTION_readconfig:\n                qemu_read_config_file(optarg, qemu_parse_config_group, &error_fatal);\n                break;\n#ifdef CONFIG_SPICE\n            case QEMU_OPTION_spice:\n                olist = qemu_find_opts_err(\"spice\", NULL);\n                if (!olist) {\n                    error_report(\"spice support is disabled\");\n                    exit(1);\n                }\n                opts = qemu_opts_parse_noisily(olist, optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                display_remote++;\n                break;\n#endif\n            case QEMU_OPTION_qtest:\n                qtest_chrdev = optarg;\n                break;\n            case QEMU_OPTION_qtest_log:\n                qtest_log = optarg;\n                break;\n            case QEMU_OPTION_sandbox:\n                olist = qemu_find_opts(\"sandbox\");\n                if (!olist) {\n#ifndef CONFIG_SECCOMP\n                    error_report(\"-sandbox support is not enabled \"\n                                 \"in this QEMU binary\");\n#endif\n                    exit(1);\n                }\n\n                opts = qemu_opts_parse_noisily(olist, optarg, true);\n                if (!opts) {\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_add_fd:\n#ifndef _WIN32\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"add-fd\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n#else\n                error_report(\"File descriptor passing is disabled on this \"\n                             \"platform\");\n                exit(1);\n#endif\n                break;\n            case QEMU_OPTION_object:\n                object_option_parse(optarg);\n                break;\n            case QEMU_OPTION_overcommit:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"overcommit\"),\n                                               optarg, false);\n                if (!opts) {\n                    exit(1);\n                }\n                enable_mlock = qemu_opt_get_bool(opts, \"mem-lock\", false);\n                enable_cpu_pm = qemu_opt_get_bool(opts, \"cpu-pm\", false);\n                break;\n            case QEMU_OPTION_compat:\n                {\n                    CompatPolicy *opts;\n                    Visitor *v;\n\n                    v = qobject_input_visitor_new_str(optarg, NULL,\n                                                      &error_fatal);\n\n                    visit_type_CompatPolicy(v, NULL, &opts, &error_fatal);\n                    QAPI_CLONE_MEMBERS(CompatPolicy, &compat_policy, opts);\n\n                    qapi_free_CompatPolicy(opts);\n                    visit_free(v);\n                    break;\n                }\n            case QEMU_OPTION_msg:\n                opts = qemu_opts_parse_noisily(qemu_find_opts(\"msg\"), optarg,\n                                               false);\n                if (!opts) {\n                    exit(1);\n                }\n                configure_msg(opts);\n                break;\n            case QEMU_OPTION_dump_vmstate:\n                if (vmstate_dump_file) {\n                    error_report(\"only one '-dump-vmstate' \"\n                                 \"option may be given\");\n                    exit(1);\n                }\n                vmstate_dump_file = fopen(optarg, \"w\");\n                if (vmstate_dump_file == NULL) {\n                    error_report(\"open %s: %s\", optarg, strerror(errno));\n                    exit(1);\n                }\n                break;\n            case QEMU_OPTION_enable_sync_profile:\n                qsp_enable();\n                break;\n            case QEMU_OPTION_nouserconfig:\n                /* Nothing to be parsed here. Especially, do not error out below. */\n                break;\n            default:\n                if (os_parse_cmd_args(popt->index, optarg)) {\n                    error_report(\"Option not supported in this build\");\n                    exit(1);\n                }\n            }\n        }\n    }\n    /*\n     * Clear error location left behind by the loop.\n     * Best done right after the loop.  Do not insert code here!\n     */\n    loc_set_none();\n\n    qemu_validate_options(machine_opts_dict);\n    qemu_process_sugar_options();\n\n    /*\n     * These options affect everything else and should be processed\n     * before daemonizing.\n     */\n    qemu_process_early_options();\n\n    qemu_process_help_options();\n    qemu_maybe_daemonize(pid_file);\n\n    /*\n     * The trace backend must be initialized after daemonizing.\n     * trace_init_backends() will call st_init(), which will create the\n     * trace thread in the parent, and also register st_flush_trace_buffer()\n     * in atexit(). This function will force the parent to wait for the\n     * writeout thread to finish, which will not occur, and the parent\n     * process will be left in the host.\n     */\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file();\n\n    qemu_init_main_loop(&error_fatal);\n    cpu_timers_init();\n\n    user_register_global_props();\n    replay_configure(icount_opts);\n\n    configure_rtc(qemu_find_opts_singleton(\"rtc\"));\n\n    /* Transfer QemuOpts options into machine options */\n    parse_memory_options();\n\n    qemu_create_machine(machine_opts_dict);\n\n    suspend_mux_open();\n\n    qemu_disable_default_devices();\n    qemu_create_default_devices();\n    qemu_create_early_backends();\n\n    qemu_apply_legacy_machine_options(machine_opts_dict);\n    qemu_apply_machine_options(machine_opts_dict);\n    qobject_unref(machine_opts_dict);\n    phase_advance(PHASE_MACHINE_CREATED);\n\n    /*\n     * Note: uses machine properties such as kernel-irqchip, must run\n     * after qemu_apply_machine_options.\n     */\n    configure_accelerators(argv[0]);\n    phase_advance(PHASE_ACCEL_CREATED);\n\n    /*\n     * Beware, QOM objects created before this point miss global and\n     * compat properties.\n     *\n     * Global properties get set up by qdev_prop_register_global(),\n     * called from user_register_global_props(), and certain option\n     * desugaring.  Also in CPU feature desugaring (buried in\n     * parse_cpu_option()), which happens below this point, but may\n     * only target the CPU type, which can only be created after\n     * parse_cpu_option() returned the type.\n     *\n     * Machine compat properties: object_set_machine_compat_props().\n     * Accelerator compat props: object_set_accelerator_compat_props(),\n     * called from do_configure_accelerator().\n     */\n\n    machine_class = MACHINE_GET_CLASS(current_machine);\n    if (!qtest_enabled() && machine_class->deprecation_reason) {\n        warn_report(\"Machine type '%s' is deprecated: %s\",\n                     machine_class->name, machine_class->deprecation_reason);\n    }\n\n    /*\n     * Note: creates a QOM object, must run only after global and\n     * compat properties have been set up.\n     */\n    migration_object_init();\n\n    qemu_create_late_backends();\n\n    /* parse features once if machine provides default cpu_type */\n    current_machine->cpu_type = machine_class->default_cpu_type;\n    if (cpu_option) {\n        current_machine->cpu_type = parse_cpu_option(cpu_option);\n    }\n    /* NB: for machine none cpu_type could STILL be NULL here! */\n\n    qemu_resolve_machine_memdev();\n    parse_numa_opts(current_machine);\n\n    if (vmstate_dump_file) {\n        /* dump and exit */\n        module_load_qom_all();\n        dump_vmstate_json_to_file(vmstate_dump_file);\n        exit(0);\n    }\n\n    if (!preconfig_requested) {\n        qmp_x_exit_preconfig(&error_fatal);\n    }\n    qemu_init_displays();\n    accel_setup_post(current_machine);\n    os_setup_post();\n    resume_mux_open();\n}\n"
}
    